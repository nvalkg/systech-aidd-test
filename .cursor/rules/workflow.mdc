---
alwaysApply: false
---
# Workflow - Правила выполнения работ

> **Базовые документы:** [vision.md](../../docs/vision.md) | [conventions.mdc](conventions.mdc) | [tasklist.md](../../docs/tasklist.md)

## 🎯 Основной принцип

**Строго следовать плану из [tasklist.md](../../docs/tasklist.md)**
- Итерации выполняются последовательно (1 → 2 → 3 → ...)
- Никаких отклонений от плана без согласования
- Каждая итерация завершается полностью перед переходом к следующей

---

## 📋 Цикл выполнения итерации

### 1️⃣ Планирование

**Перед началом итерации:**
- [ ] Изучить задачи текущей итерации из tasklist.md
- [ ] Предложить решение с отрезками кода для каждой задачи
- [ ] Показать структуру файлов и ключевые методы
- [ ] **Дождаться согласования от разработчика**

**Формат предложения:**
```markdown
## Итерация N: [Название]

### Структура
- файл1.py - краткое описание
- файл2.py - краткое описание

### Ключевые фрагменты кода
[Показать сигнатуры классов и методов]

Согласовать?
```

### 2️⃣ Реализация

**После согласования:**
- [ ] Создать/изменить файлы согласно плану
- [ ] Следовать [conventions.mdc](conventions.mdc) (1 класс = 1 файл, KISS, async)
- [ ] Следовать [vision.md](../../docs/vision.md) для технических решений
- [ ] Добавить необходимое логирование
- [ ] Проверить code style (PEP 8, type hints)

### 3️⃣ Проверка

**После реализации:**
- [ ] Выполнить тест из tasklist.md для текущей итерации
- [ ] Показать результаты тестирования
- [ ] Исправить ошибки при наличии
- [ ] **Дождаться подтверждения от разработчика**

**Проверка качества (для tech debt итераций):**
- [ ] Запустить `make format` - автоформатирование
- [ ] Запустить `make lint` - исправить все замечания
- [ ] Запустить `make typecheck` - исправить ошибки типов
- [ ] Запустить `make test` - все тесты должны пройти
- [ ] Запустить `make quality` - финальная проверка

### 3️⃣+ TDD практики (Test-Driven Development)

**Когда применять TDD:**
- При добавлении новой функциональности
- При рефакторинге существующего кода
- При исправлении багов

**Цикл TDD (Red-Green-Refactor):**

1. **🔴 Red - Написать тест**
   - Сначала пишем failing тест для новой функциональности
   - Тест описывает желаемое поведение
   - Запускаем `make test` - тест должен упасть
   
2. **🟢 Green - Реализовать код**
   - Пишем минимальный код для прохождения теста
   - Запускаем `make test` - тест должен пройти
   - Фокус на работоспособности, не на оптимальности
   
3. **🔵 Refactor - Улучшить код**
   - Рефакторим код с сохранением поведения
   - Запускаем `make test` - все тесты проходят
   - Применяем SOLID, DRY, удаляем дублирование

**Пример TDD цикла:**

```python
# 1. Red: Пишем тест
def test_get_response_handles_empty_content():
    """LLM может вернуть пустой content - нужно обработать"""
    llm = LLMClient("test-key", "test-model", 100, 0.7)
    mock_response = Mock(choices=[Mock(message=Mock(content=None))])
    
    with patch.object(llm.client.chat.completions, 'create') as mock:
        mock.return_value = mock_response
        result = await llm.get_response([{"role": "user", "content": "Hi"}])
        
        # Ожидаем, что None превратится в пустую строку
        assert result == ""

# Запускаем: make test → FAILED (content может быть None, тест падает)

# 2. Green: Минимальная реализация
async def get_response(self, messages: list[dict[str, Any]]) -> str:
    response = await self.client.chat.completions.create(...)
    content = response.choices[0].message.content
    if content is None:  # Добавили проверку
        content = ""
    return content

# Запускаем: make test → PASSED

# 3. Refactor: Улучшаем (если нужно)
# В данном случае код уже хорош, дополнительный рефакторинг не требуется
# Запускаем: make test → PASSED
```

**Преимущества TDD:**
- ✅ Тесты документируют поведение
- ✅ Высокий coverage (часто >90%)
- ✅ Меньше регрессий при изменениях
- ✅ Дизайн кода улучшается (testable code = good code)

**TDD для багфиксов:**
1. Написать тест, воспроизводящий баг (Red)
2. Исправить баг (Green)
3. Рефакторить при необходимости (Refactor)
4. Баг больше не вернется - есть тест!

### 4️⃣ Фиксация

**После подтверждения:**
- [ ] Обновить таблицу прогресса в tasklist.md (статус ✅ Done, дата)
- [ ] Отметить все выполненные задачи чекбоксами [x]
- [ ] Создать коммит: `git commit -m "feat: iteration N - [название]"`
- [ ] **Согласовать переход к следующей итерации**

---

## 🔄 Пример workflow

```
┌─────────────────────────────────────────────────────┐
│ 1. Планирование                                     │
│    - Изучить итерацию                              │
│    - Предложить решение                            │
│    → Ожидание согласования                         │
└─────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────┐
│ 2. Реализация                                       │
│    - Создать файлы                                 │
│    - Реализовать код                               │
│    - Следовать conventions                         │
└─────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────┐
│ 3. Проверка                                         │
│    - Выполнить тест                                │
│    - Показать результаты                           │
│    → Ожидание подтверждения                        │
└─────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────┐
│ 4. Фиксация                                         │
│    - Обновить tasklist.md                          │
│    - Сделать коммит                                │
│    → Согласовать переход к следующей итерации      │
└─────────────────────────────────────────────────────┘
```

---

## ⚠️ Важные правила

### Обязательные точки согласования
1. **Перед реализацией** - предложить решение и дождаться одобрения
2. **После реализации** - дождаться подтверждения тестирования
3. **Переход к следующей итерации** - получить явное разрешение

### Что делать при проблемах
- **Ошибка в коде** - исправить и повторить тест
- **Неясность в задаче** - задать вопрос перед реализацией
- **Блокер** - обновить статус на ❌ Blocked с описанием проблемы

### Обновление tasklist.md
- Обновляется **только после успешного тестирования**
- Формат даты: `YYYY-MM-DD`
- Статусы: ⏳ Pending → 🔄 In Progress → ✅ Done

### Коммиты
**Формат сообщения:**
```
feat: iteration N - краткое описание

- задача 1
- задача 2
- задача 3
```

**Примеры:**
```
feat: iteration 1 - project setup and config
feat: iteration 2 - llm client integration
feat: iteration 3 - conversation manager
```

---

## 📝 Checklist перед каждой итерацией

- [ ] Изучены задачи из tasklist.md
- [ ] Изучены требования из docs/vision.md
- [ ] Изучены правила из conventions.mdc
- [ ] Подготовлен план с фрагментами кода
- [ ] План согласован с разработчиком

## 📝 Checklist после каждой итерации

- [ ] Все задачи реализованы
- [ ] Тест выполнен успешно
- [ ] Подтверждение получено
- [ ] tasklist.md обновлен (таблица + чекбоксы)
- [ ] Коммит создан
- [ ] Разрешение на следующую итерацию получено

---

## 🚀 Начало работы

**Перед стартом убедиться:**
1. ✅ Файл [vision.md](../../docs/vision.md) изучен
2. ✅ Файл [conventions.mdc](conventions.mdc) изучен
3. ✅ Файл [tasklist.md](../../docs/tasklist.md) изучен
4. ✅ Репозиторий готов к работе

**Первая команда:**
```
"Начинаем итерацию 1 по tasklist.md. Предлагаю решение..."
```

---

## 📊 Coverage и качество тестов

### Целевые метрики
- **Общий coverage:** >80%
- **Критичные модули:** 100% (config, models)
- **Бизнес-логика:** >90% (llm_client, conversation_manager)
- **Интеграция:** >80% (telegram_bot, main)

### Команды для coverage
```bash
# Обычный запуск с coverage
make test

# Детальный HTML отчет
pytest --cov=src --cov-report=html
# Открыть htmlcov/index.html в браузере

# Coverage для конкретного модуля
pytest tests/test_llm_client.py --cov=src.llm_client --cov-report=term-missing
```

### Интерпретация результатов
```
Name                    Stmts   Miss  Cover   Missing
-----------------------------------------------------
src/config.py              30      0   100%
src/llm_client.py          24      1    96%   58
src/main.py                34      1    97%   72
-----------------------------------------------------
TOTAL                     257     12    95%
```

- **Stmts** - количество исполняемых строк
- **Miss** - непокрытые строки
- **Cover** - процент покрытия
- **Missing** - номера непокрытых строк

**Что не покрывать:**
- `if __name__ == "__main__":` блоки
- Entry points (src/__main__.py)
- Логирование (logger.info/error)
- Trivial property accessors

---

## CI/CD процесс

### Автоматизация в GitHub Actions

**Файл:** `.github/workflows/quality.yml`

**Триггеры:**
- Push в ветки: main, develop, day03-refactor
- Pull Request в ветки: main, develop

**Этапы проверки:**
```yaml
1. Checkout: Получение кода из репозитория
2. Setup uv: Установка менеджера пакетов uv
3. Setup Python: Установка Python 3.11
4. Install deps: uv sync --dev
5. Format check: ruff format src/ --check
6. Lint: ruff check src/
7. Typecheck: mypy src/
8. Tests: pytest --cov=src --cov-report=xml
9. Upload coverage: codecov (опционально)
```

**Статус:** Проверки проходят автоматически, результат отображается в PR

### Локальный workflow перед push

**Полный цикл разработки:**

```bash
# 1. Создание feature-ветки
git checkout -b feature/my-new-feature

# 2. Разработка
vim src/my_module.py

# 3. Написание тестов
vim tests/test_my_module.py

# 4. Локальная проверка качества (ОБЯЗАТЕЛЬНО!)
make quality

# 5. Если все прошло - коммит
git add .
git commit -m "feat: добавлена новая фича"

# 6. Push (запустится CI в GitHub)
git push origin feature/my-new-feature

# 7. Создание PR на GitHub
# Дождаться прохождения CI checks
# Запросить code review
```

### Что делать если CI failed

**1. Format check failed:**
```bash
# Локально исправить форматирование
make format

# Добавить изменения
git add .

# Amend последнего коммита
git commit --amend --no-edit

# Force push с защитой
git push --force-with-lease
```

**2. Lint check failed:**
```bash
# Проверить ошибки
make lint

# Исправить код
# ...

# Amend и push
git add .
git commit --amend --no-edit
git push --force-with-lease
```

**3. Typecheck failed:**
```bash
# Проверить ошибки типов
make typecheck

# Добавить type hints
# ...

# Amend и push
git add .
git commit --amend --no-edit
git push --force-with-lease
```

**4. Tests failed:**
```bash
# Запустить тесты локально
make test

# Посмотреть детали ошибки
uv run pytest tests/test_my_module.py -v

# Исправить код или тесты
# ...

# Amend и push
git add .
git commit --amend --no-edit
git push --force-with-lease
```

### Преимущества CI/CD

**Для разработчиков:**
- ✅ Автоматическая проверка качества кода
- ✅ Раннее обнаружение ошибок (до code review)
- ✅ Единый стандарт для всей команды
- ✅ Меньше времени на ручные проверки

**Для проекта:**
- ✅ Стабильность main ветки
- ✅ Предотвращение merge плохого кода
- ✅ Контроль coverage (не даем ему упасть)
- ✅ Документированные требования (CI config)

**Для code review:**
- ✅ Reviewer видит статус CI сразу
- ✅ Фокус на архитектуре, не на синтаксисе
- ✅ Автоматическая проверка стандартов

### Badges в README

Добавлены badges для визуализации статуса проекта:

```markdown
![Python Version](https://img.shields.io/badge/python-3.11+-blue.svg)
![CI Status](https://img.shields.io/badge/CI-passing-brightgreen.svg)
![Coverage](https://img.shields.io/badge/coverage-95%25-brightgreen.svg)
![License](https://img.shields.io/badge/license-MIT-green.svg)
```

### Процесс PR Review

**Checklist для reviewer:**

1. **CI Status:**
   - [ ] All checks passed ✅
   - [ ] Coverage не упал

2. **Код:**
   - [ ] Соблюдение SOLID (особенно SRP)
   - [ ] Отсутствие дублирования (DRY)
   - [ ] Type hints для публичных методов
   - [ ] Понятные имена переменных

3. **Тесты:**
   - [ ] Новый функционал покрыт тестами
   - [ ] Тесты используют моки для внешних зависимостей
   - [ ] Arrange-Act-Assert структура

4. **Документация:**
   - [ ] README обновлен (если нужно)
   - [ ] Docstrings добавлены/обновлены
   - [ ] CONTRIBUTING.md актуален

### Merge стратегия

**Требования для merge в main:**
- ✅ CI passed
- ✅ Code review approved (минимум 1 reviewer)
- ✅ Конфликты разрешены
- ✅ Coverage >= 95%

**Тип merge:**
- Используем **Squash and merge** для feature веток
- Сохраняем чистую историю в main
- Conventional commit message для squash

---

**Версия:** 2.0  
**Создан:** 2025-01-15  
**Обновлено:** 2025-10-11 (добавлен CI/CD процесс, PR review workflow)  
**Принцип:** Quality First - CI/CD гарантирует качество на каждом этапе
